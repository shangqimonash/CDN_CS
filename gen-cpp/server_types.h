/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef server_TYPES_H
#define server_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <functional>
#include <memory>


namespace services {

class tBlock_pos;

class tMetaRangeRet_p1;

class tMetaRangeRet_p2;

class tPhysicalLocation;

class tMetaOblivEvict;

class tMetaPerRe;

class tMetaPriRangeRet;

class tFullBlockContent;

typedef struct _tBlock_pos__isset {
  _tBlock_pos__isset() : path(false), bu(false), offset(false) {}
  bool path :1;
  bool bu :1;
  bool offset :1;
} _tBlock_pos__isset;

class tBlock_pos : public virtual ::apache::thrift::TBase {
 public:

  tBlock_pos(const tBlock_pos&);
  tBlock_pos& operator=(const tBlock_pos&);
  tBlock_pos() : path(0), bu(0), offset(0) {
  }

  virtual ~tBlock_pos() noexcept;
  int32_t path;
  int32_t bu;
  int32_t offset;

  _tBlock_pos__isset __isset;

  void __set_path(const int32_t val);

  void __set_bu(const int32_t val);

  void __set_offset(const int32_t val);

  bool operator == (const tBlock_pos & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    if (!(bu == rhs.bu))
      return false;
    if (!(offset == rhs.offset))
      return false;
    return true;
  }
  bool operator != (const tBlock_pos &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const tBlock_pos & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(tBlock_pos &a, tBlock_pos &b);

std::ostream& operator<<(std::ostream& out, const tBlock_pos& obj);

typedef struct _tMetaRangeRet_p1__isset {
  _tMetaRangeRet_p1__isset() : tag1(false), tag2(false), k_part1(false) {}
  bool tag1 :1;
  bool tag2 :1;
  bool k_part1 :1;
} _tMetaRangeRet_p1__isset;

class tMetaRangeRet_p1 : public virtual ::apache::thrift::TBase {
 public:

  tMetaRangeRet_p1(const tMetaRangeRet_p1&);
  tMetaRangeRet_p1& operator=(const tMetaRangeRet_p1&);
  tMetaRangeRet_p1() {
  }

  virtual ~tMetaRangeRet_p1() noexcept;
  std::vector<int8_t>  tag1;
  std::vector<int8_t>  tag2;
  std::vector<int8_t>  k_part1;

  _tMetaRangeRet_p1__isset __isset;

  void __set_tag1(const std::vector<int8_t> & val);

  void __set_tag2(const std::vector<int8_t> & val);

  void __set_k_part1(const std::vector<int8_t> & val);

  bool operator == (const tMetaRangeRet_p1 & rhs) const
  {
    if (!(tag1 == rhs.tag1))
      return false;
    if (!(tag2 == rhs.tag2))
      return false;
    if (!(k_part1 == rhs.k_part1))
      return false;
    return true;
  }
  bool operator != (const tMetaRangeRet_p1 &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const tMetaRangeRet_p1 & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(tMetaRangeRet_p1 &a, tMetaRangeRet_p1 &b);

std::ostream& operator<<(std::ostream& out, const tMetaRangeRet_p1& obj);

typedef struct _tMetaRangeRet_p2__isset {
  _tMetaRangeRet_p2__isset() : tag2(false), k_part2(false), s(false), oramIndex(false) {}
  bool tag2 :1;
  bool k_part2 :1;
  bool s :1;
  bool oramIndex :1;
} _tMetaRangeRet_p2__isset;

class tMetaRangeRet_p2 : public virtual ::apache::thrift::TBase {
 public:

  tMetaRangeRet_p2(const tMetaRangeRet_p2&);
  tMetaRangeRet_p2& operator=(const tMetaRangeRet_p2&);
  tMetaRangeRet_p2() : s(0), oramIndex(0) {
  }

  virtual ~tMetaRangeRet_p2() noexcept;
  std::vector<int8_t>  tag2;
  std::vector<int8_t>  k_part2;
  int32_t s;
  int32_t oramIndex;

  _tMetaRangeRet_p2__isset __isset;

  void __set_tag2(const std::vector<int8_t> & val);

  void __set_k_part2(const std::vector<int8_t> & val);

  void __set_s(const int32_t val);

  void __set_oramIndex(const int32_t val);

  bool operator == (const tMetaRangeRet_p2 & rhs) const
  {
    if (!(tag2 == rhs.tag2))
      return false;
    if (!(k_part2 == rhs.k_part2))
      return false;
    if (!(s == rhs.s))
      return false;
    if (!(oramIndex == rhs.oramIndex))
      return false;
    return true;
  }
  bool operator != (const tMetaRangeRet_p2 &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const tMetaRangeRet_p2 & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(tMetaRangeRet_p2 &a, tMetaRangeRet_p2 &b);

std::ostream& operator<<(std::ostream& out, const tMetaRangeRet_p2& obj);

typedef struct _tPhysicalLocation__isset {
  _tPhysicalLocation__isset() : leafLabel(false), bucketLevel(false), bucketOffset(false) {}
  bool leafLabel :1;
  bool bucketLevel :1;
  bool bucketOffset :1;
} _tPhysicalLocation__isset;

class tPhysicalLocation : public virtual ::apache::thrift::TBase {
 public:

  tPhysicalLocation(const tPhysicalLocation&);
  tPhysicalLocation& operator=(const tPhysicalLocation&);
  tPhysicalLocation() : leafLabel(0), bucketLevel(0), bucketOffset(0) {
  }

  virtual ~tPhysicalLocation() noexcept;
  int32_t leafLabel;
  int32_t bucketLevel;
  int32_t bucketOffset;

  _tPhysicalLocation__isset __isset;

  void __set_leafLabel(const int32_t val);

  void __set_bucketLevel(const int32_t val);

  void __set_bucketOffset(const int32_t val);

  bool operator == (const tPhysicalLocation & rhs) const
  {
    if (!(leafLabel == rhs.leafLabel))
      return false;
    if (!(bucketLevel == rhs.bucketLevel))
      return false;
    if (!(bucketOffset == rhs.bucketOffset))
      return false;
    return true;
  }
  bool operator != (const tPhysicalLocation &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const tPhysicalLocation & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(tPhysicalLocation &a, tPhysicalLocation &b);

std::ostream& operator<<(std::ostream& out, const tPhysicalLocation& obj);

typedef struct _tMetaOblivEvict__isset {
  _tMetaOblivEvict__isset() : tag(false), key_arr(false), round(false), ks(false), k_part(false), oramIndex(false), bu(false), path(false), offset(false) {}
  bool tag :1;
  bool key_arr :1;
  bool round :1;
  bool ks :1;
  bool k_part :1;
  bool oramIndex :1;
  bool bu :1;
  bool path :1;
  bool offset :1;
} _tMetaOblivEvict__isset;

class tMetaOblivEvict : public virtual ::apache::thrift::TBase {
 public:

  tMetaOblivEvict(const tMetaOblivEvict&);
  tMetaOblivEvict& operator=(const tMetaOblivEvict&);
  tMetaOblivEvict() : round(0), oramIndex(0), bu(0), path(0), offset(0) {
  }

  virtual ~tMetaOblivEvict() noexcept;
  std::vector<int8_t>  tag;
  std::vector<int32_t>  key_arr;
  int32_t round;
  std::vector<int8_t>  ks;
  std::vector<int8_t>  k_part;
  int32_t oramIndex;
  int32_t bu;
  int32_t path;
  int32_t offset;

  _tMetaOblivEvict__isset __isset;

  void __set_tag(const std::vector<int8_t> & val);

  void __set_key_arr(const std::vector<int32_t> & val);

  void __set_round(const int32_t val);

  void __set_ks(const std::vector<int8_t> & val);

  void __set_k_part(const std::vector<int8_t> & val);

  void __set_oramIndex(const int32_t val);

  void __set_bu(const int32_t val);

  void __set_path(const int32_t val);

  void __set_offset(const int32_t val);

  bool operator == (const tMetaOblivEvict & rhs) const
  {
    if (!(tag == rhs.tag))
      return false;
    if (!(key_arr == rhs.key_arr))
      return false;
    if (!(round == rhs.round))
      return false;
    if (!(ks == rhs.ks))
      return false;
    if (!(k_part == rhs.k_part))
      return false;
    if (!(oramIndex == rhs.oramIndex))
      return false;
    if (!(bu == rhs.bu))
      return false;
    if (!(path == rhs.path))
      return false;
    if (!(offset == rhs.offset))
      return false;
    return true;
  }
  bool operator != (const tMetaOblivEvict &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const tMetaOblivEvict & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(tMetaOblivEvict &a, tMetaOblivEvict &b);

std::ostream& operator<<(std::ostream& out, const tMetaOblivEvict& obj);

typedef struct _tMetaPerRe__isset {
  _tMetaPerRe__isset() : originIndex(false), newIndex(false), k_part(false) {}
  bool originIndex :1;
  bool newIndex :1;
  bool k_part :1;
} _tMetaPerRe__isset;

class tMetaPerRe : public virtual ::apache::thrift::TBase {
 public:

  tMetaPerRe(const tMetaPerRe&);
  tMetaPerRe& operator=(const tMetaPerRe&);
  tMetaPerRe() : originIndex(0), newIndex(0) {
  }

  virtual ~tMetaPerRe() noexcept;
  int32_t originIndex;
  int32_t newIndex;
  std::vector<int8_t>  k_part;

  _tMetaPerRe__isset __isset;

  void __set_originIndex(const int32_t val);

  void __set_newIndex(const int32_t val);

  void __set_k_part(const std::vector<int8_t> & val);

  bool operator == (const tMetaPerRe & rhs) const
  {
    if (!(originIndex == rhs.originIndex))
      return false;
    if (!(newIndex == rhs.newIndex))
      return false;
    if (!(k_part == rhs.k_part))
      return false;
    return true;
  }
  bool operator != (const tMetaPerRe &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const tMetaPerRe & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(tMetaPerRe &a, tMetaPerRe &b);

std::ostream& operator<<(std::ostream& out, const tMetaPerRe& obj);

typedef struct _tMetaPriRangeRet__isset {
  _tMetaPriRangeRet__isset() : tag(false), key_arr(false), round(false), ks(false), k_part(false), oramIndex(false), path(false), bu_from(false), bu_max_inclusive(false), offset(false), stash_index(false) {}
  bool tag :1;
  bool key_arr :1;
  bool round :1;
  bool ks :1;
  bool k_part :1;
  bool oramIndex :1;
  bool path :1;
  bool bu_from :1;
  bool bu_max_inclusive :1;
  bool offset :1;
  bool stash_index :1;
} _tMetaPriRangeRet__isset;

class tMetaPriRangeRet : public virtual ::apache::thrift::TBase {
 public:

  tMetaPriRangeRet(const tMetaPriRangeRet&);
  tMetaPriRangeRet& operator=(const tMetaPriRangeRet&);
  tMetaPriRangeRet() : round(0), oramIndex(0), path(0), bu_from(0), bu_max_inclusive(0), offset(0), stash_index(0) {
  }

  virtual ~tMetaPriRangeRet() noexcept;
  std::vector<int8_t>  tag;
  std::vector<int32_t>  key_arr;
  int32_t round;
  std::vector<int8_t>  ks;
  std::vector<int8_t>  k_part;
  int32_t oramIndex;
  int32_t path;
  int32_t bu_from;
  int32_t bu_max_inclusive;
  int32_t offset;
  int32_t stash_index;

  _tMetaPriRangeRet__isset __isset;

  void __set_tag(const std::vector<int8_t> & val);

  void __set_key_arr(const std::vector<int32_t> & val);

  void __set_round(const int32_t val);

  void __set_ks(const std::vector<int8_t> & val);

  void __set_k_part(const std::vector<int8_t> & val);

  void __set_oramIndex(const int32_t val);

  void __set_path(const int32_t val);

  void __set_bu_from(const int32_t val);

  void __set_bu_max_inclusive(const int32_t val);

  void __set_offset(const int32_t val);

  void __set_stash_index(const int32_t val);

  bool operator == (const tMetaPriRangeRet & rhs) const
  {
    if (!(tag == rhs.tag))
      return false;
    if (!(key_arr == rhs.key_arr))
      return false;
    if (!(round == rhs.round))
      return false;
    if (!(ks == rhs.ks))
      return false;
    if (!(k_part == rhs.k_part))
      return false;
    if (!(oramIndex == rhs.oramIndex))
      return false;
    if (!(path == rhs.path))
      return false;
    if (!(bu_from == rhs.bu_from))
      return false;
    if (!(bu_max_inclusive == rhs.bu_max_inclusive))
      return false;
    if (!(offset == rhs.offset))
      return false;
    if (!(stash_index == rhs.stash_index))
      return false;
    return true;
  }
  bool operator != (const tMetaPriRangeRet &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const tMetaPriRangeRet & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(tMetaPriRangeRet &a, tMetaPriRangeRet &b);

std::ostream& operator<<(std::ostream& out, const tMetaPriRangeRet& obj);

typedef struct _tFullBlockContent__isset {
  _tFullBlockContent__isset() : leafLabel(false), bucketLevel(false), bucketOffset(false), encData(false) {}
  bool leafLabel :1;
  bool bucketLevel :1;
  bool bucketOffset :1;
  bool encData :1;
} _tFullBlockContent__isset;

class tFullBlockContent : public virtual ::apache::thrift::TBase {
 public:

  tFullBlockContent(const tFullBlockContent&);
  tFullBlockContent& operator=(const tFullBlockContent&);
  tFullBlockContent() : leafLabel(0), bucketLevel(0), bucketOffset(0) {
  }

  virtual ~tFullBlockContent() noexcept;
  int32_t leafLabel;
  int32_t bucketLevel;
  int32_t bucketOffset;
  std::vector<int8_t>  encData;

  _tFullBlockContent__isset __isset;

  void __set_leafLabel(const int32_t val);

  void __set_bucketLevel(const int32_t val);

  void __set_bucketOffset(const int32_t val);

  void __set_encData(const std::vector<int8_t> & val);

  bool operator == (const tFullBlockContent & rhs) const
  {
    if (!(leafLabel == rhs.leafLabel))
      return false;
    if (!(bucketLevel == rhs.bucketLevel))
      return false;
    if (!(bucketOffset == rhs.bucketOffset))
      return false;
    if (!(encData == rhs.encData))
      return false;
    return true;
  }
  bool operator != (const tFullBlockContent &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const tFullBlockContent & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(tFullBlockContent &a, tFullBlockContent &b);

std::ostream& operator<<(std::ostream& out, const tFullBlockContent& obj);

} // namespace

#endif
