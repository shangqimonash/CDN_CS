/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "server_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace services {


tBlock_pos::~tBlock_pos() noexcept {
}


void tBlock_pos::__set_path(const int32_t val) {
  this->path = val;
}

void tBlock_pos::__set_bu(const int32_t val) {
  this->bu = val;
}

void tBlock_pos::__set_offset(const int32_t val) {
  this->offset = val;
}
std::ostream& operator<<(std::ostream& out, const tBlock_pos& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t tBlock_pos::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bu);
          this->__isset.bu = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->offset);
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t tBlock_pos::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("tBlock_pos");

  xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bu", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->bu);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->offset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(tBlock_pos &a, tBlock_pos &b) {
  using ::std::swap;
  swap(a.path, b.path);
  swap(a.bu, b.bu);
  swap(a.offset, b.offset);
  swap(a.__isset, b.__isset);
}

tBlock_pos::tBlock_pos(const tBlock_pos& other0) {
  path = other0.path;
  bu = other0.bu;
  offset = other0.offset;
  __isset = other0.__isset;
}
tBlock_pos& tBlock_pos::operator=(const tBlock_pos& other1) {
  path = other1.path;
  bu = other1.bu;
  offset = other1.offset;
  __isset = other1.__isset;
  return *this;
}
void tBlock_pos::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "tBlock_pos(";
  out << "path=" << to_string(path);
  out << ", " << "bu=" << to_string(bu);
  out << ", " << "offset=" << to_string(offset);
  out << ")";
}


tMetaRangeRet_p1::~tMetaRangeRet_p1() noexcept {
}


void tMetaRangeRet_p1::__set_tag1(const std::vector<int8_t> & val) {
  this->tag1 = val;
}

void tMetaRangeRet_p1::__set_tag2(const std::vector<int8_t> & val) {
  this->tag2 = val;
}

void tMetaRangeRet_p1::__set_k_part1(const std::vector<int8_t> & val) {
  this->k_part1 = val;
}
std::ostream& operator<<(std::ostream& out, const tMetaRangeRet_p1& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t tMetaRangeRet_p1::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tag1.clear();
            uint32_t _size2;
            ::apache::thrift::protocol::TType _etype5;
            xfer += iprot->readListBegin(_etype5, _size2);
            this->tag1.resize(_size2);
            uint32_t _i6;
            for (_i6 = 0; _i6 < _size2; ++_i6)
            {
              xfer += iprot->readByte(this->tag1[_i6]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tag1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tag2.clear();
            uint32_t _size7;
            ::apache::thrift::protocol::TType _etype10;
            xfer += iprot->readListBegin(_etype10, _size7);
            this->tag2.resize(_size7);
            uint32_t _i11;
            for (_i11 = 0; _i11 < _size7; ++_i11)
            {
              xfer += iprot->readByte(this->tag2[_i11]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tag2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k_part1.clear();
            uint32_t _size12;
            ::apache::thrift::protocol::TType _etype15;
            xfer += iprot->readListBegin(_etype15, _size12);
            this->k_part1.resize(_size12);
            uint32_t _i16;
            for (_i16 = 0; _i16 < _size12; ++_i16)
            {
              xfer += iprot->readByte(this->k_part1[_i16]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.k_part1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t tMetaRangeRet_p1::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("tMetaRangeRet_p1");

  xfer += oprot->writeFieldBegin("tag1", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BYTE, static_cast<uint32_t>(this->tag1.size()));
    std::vector<int8_t> ::const_iterator _iter17;
    for (_iter17 = this->tag1.begin(); _iter17 != this->tag1.end(); ++_iter17)
    {
      xfer += oprot->writeByte((*_iter17));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tag2", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BYTE, static_cast<uint32_t>(this->tag2.size()));
    std::vector<int8_t> ::const_iterator _iter18;
    for (_iter18 = this->tag2.begin(); _iter18 != this->tag2.end(); ++_iter18)
    {
      xfer += oprot->writeByte((*_iter18));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("k_part1", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BYTE, static_cast<uint32_t>(this->k_part1.size()));
    std::vector<int8_t> ::const_iterator _iter19;
    for (_iter19 = this->k_part1.begin(); _iter19 != this->k_part1.end(); ++_iter19)
    {
      xfer += oprot->writeByte((*_iter19));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(tMetaRangeRet_p1 &a, tMetaRangeRet_p1 &b) {
  using ::std::swap;
  swap(a.tag1, b.tag1);
  swap(a.tag2, b.tag2);
  swap(a.k_part1, b.k_part1);
  swap(a.__isset, b.__isset);
}

tMetaRangeRet_p1::tMetaRangeRet_p1(const tMetaRangeRet_p1& other20) {
  tag1 = other20.tag1;
  tag2 = other20.tag2;
  k_part1 = other20.k_part1;
  __isset = other20.__isset;
}
tMetaRangeRet_p1& tMetaRangeRet_p1::operator=(const tMetaRangeRet_p1& other21) {
  tag1 = other21.tag1;
  tag2 = other21.tag2;
  k_part1 = other21.k_part1;
  __isset = other21.__isset;
  return *this;
}
void tMetaRangeRet_p1::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "tMetaRangeRet_p1(";
  out << "tag1=" << to_string(tag1);
  out << ", " << "tag2=" << to_string(tag2);
  out << ", " << "k_part1=" << to_string(k_part1);
  out << ")";
}


tMetaRangeRet_p2::~tMetaRangeRet_p2() noexcept {
}


void tMetaRangeRet_p2::__set_tag2(const std::vector<int8_t> & val) {
  this->tag2 = val;
}

void tMetaRangeRet_p2::__set_k_part2(const std::vector<int8_t> & val) {
  this->k_part2 = val;
}

void tMetaRangeRet_p2::__set_s(const int32_t val) {
  this->s = val;
}

void tMetaRangeRet_p2::__set_oramIndex(const int32_t val) {
  this->oramIndex = val;
}
std::ostream& operator<<(std::ostream& out, const tMetaRangeRet_p2& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t tMetaRangeRet_p2::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tag2.clear();
            uint32_t _size22;
            ::apache::thrift::protocol::TType _etype25;
            xfer += iprot->readListBegin(_etype25, _size22);
            this->tag2.resize(_size22);
            uint32_t _i26;
            for (_i26 = 0; _i26 < _size22; ++_i26)
            {
              xfer += iprot->readByte(this->tag2[_i26]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tag2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k_part2.clear();
            uint32_t _size27;
            ::apache::thrift::protocol::TType _etype30;
            xfer += iprot->readListBegin(_etype30, _size27);
            this->k_part2.resize(_size27);
            uint32_t _i31;
            for (_i31 = 0; _i31 < _size27; ++_i31)
            {
              xfer += iprot->readByte(this->k_part2[_i31]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.k_part2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->s);
          this->__isset.s = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->oramIndex);
          this->__isset.oramIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t tMetaRangeRet_p2::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("tMetaRangeRet_p2");

  xfer += oprot->writeFieldBegin("tag2", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BYTE, static_cast<uint32_t>(this->tag2.size()));
    std::vector<int8_t> ::const_iterator _iter32;
    for (_iter32 = this->tag2.begin(); _iter32 != this->tag2.end(); ++_iter32)
    {
      xfer += oprot->writeByte((*_iter32));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("k_part2", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BYTE, static_cast<uint32_t>(this->k_part2.size()));
    std::vector<int8_t> ::const_iterator _iter33;
    for (_iter33 = this->k_part2.begin(); _iter33 != this->k_part2.end(); ++_iter33)
    {
      xfer += oprot->writeByte((*_iter33));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("s", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->s);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("oramIndex", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->oramIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(tMetaRangeRet_p2 &a, tMetaRangeRet_p2 &b) {
  using ::std::swap;
  swap(a.tag2, b.tag2);
  swap(a.k_part2, b.k_part2);
  swap(a.s, b.s);
  swap(a.oramIndex, b.oramIndex);
  swap(a.__isset, b.__isset);
}

tMetaRangeRet_p2::tMetaRangeRet_p2(const tMetaRangeRet_p2& other34) {
  tag2 = other34.tag2;
  k_part2 = other34.k_part2;
  s = other34.s;
  oramIndex = other34.oramIndex;
  __isset = other34.__isset;
}
tMetaRangeRet_p2& tMetaRangeRet_p2::operator=(const tMetaRangeRet_p2& other35) {
  tag2 = other35.tag2;
  k_part2 = other35.k_part2;
  s = other35.s;
  oramIndex = other35.oramIndex;
  __isset = other35.__isset;
  return *this;
}
void tMetaRangeRet_p2::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "tMetaRangeRet_p2(";
  out << "tag2=" << to_string(tag2);
  out << ", " << "k_part2=" << to_string(k_part2);
  out << ", " << "s=" << to_string(s);
  out << ", " << "oramIndex=" << to_string(oramIndex);
  out << ")";
}


tPhysicalLocation::~tPhysicalLocation() noexcept {
}


void tPhysicalLocation::__set_leafLabel(const int32_t val) {
  this->leafLabel = val;
}

void tPhysicalLocation::__set_bucketLevel(const int32_t val) {
  this->bucketLevel = val;
}

void tPhysicalLocation::__set_bucketOffset(const int32_t val) {
  this->bucketOffset = val;
}
std::ostream& operator<<(std::ostream& out, const tPhysicalLocation& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t tPhysicalLocation::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->leafLabel);
          this->__isset.leafLabel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bucketLevel);
          this->__isset.bucketLevel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bucketOffset);
          this->__isset.bucketOffset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t tPhysicalLocation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("tPhysicalLocation");

  xfer += oprot->writeFieldBegin("leafLabel", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->leafLabel);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bucketLevel", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->bucketLevel);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bucketOffset", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->bucketOffset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(tPhysicalLocation &a, tPhysicalLocation &b) {
  using ::std::swap;
  swap(a.leafLabel, b.leafLabel);
  swap(a.bucketLevel, b.bucketLevel);
  swap(a.bucketOffset, b.bucketOffset);
  swap(a.__isset, b.__isset);
}

tPhysicalLocation::tPhysicalLocation(const tPhysicalLocation& other36) {
  leafLabel = other36.leafLabel;
  bucketLevel = other36.bucketLevel;
  bucketOffset = other36.bucketOffset;
  __isset = other36.__isset;
}
tPhysicalLocation& tPhysicalLocation::operator=(const tPhysicalLocation& other37) {
  leafLabel = other37.leafLabel;
  bucketLevel = other37.bucketLevel;
  bucketOffset = other37.bucketOffset;
  __isset = other37.__isset;
  return *this;
}
void tPhysicalLocation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "tPhysicalLocation(";
  out << "leafLabel=" << to_string(leafLabel);
  out << ", " << "bucketLevel=" << to_string(bucketLevel);
  out << ", " << "bucketOffset=" << to_string(bucketOffset);
  out << ")";
}


tMetaOblivEvict::~tMetaOblivEvict() noexcept {
}


void tMetaOblivEvict::__set_tag(const std::vector<int8_t> & val) {
  this->tag = val;
}

void tMetaOblivEvict::__set_key_arr(const std::vector<int32_t> & val) {
  this->key_arr = val;
}

void tMetaOblivEvict::__set_round(const int32_t val) {
  this->round = val;
}

void tMetaOblivEvict::__set_ks(const std::vector<int8_t> & val) {
  this->ks = val;
}

void tMetaOblivEvict::__set_k_part(const std::vector<int8_t> & val) {
  this->k_part = val;
}

void tMetaOblivEvict::__set_oramIndex(const int32_t val) {
  this->oramIndex = val;
}

void tMetaOblivEvict::__set_bu(const int32_t val) {
  this->bu = val;
}

void tMetaOblivEvict::__set_path(const int32_t val) {
  this->path = val;
}

void tMetaOblivEvict::__set_offset(const int32_t val) {
  this->offset = val;
}
std::ostream& operator<<(std::ostream& out, const tMetaOblivEvict& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t tMetaOblivEvict::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tag.clear();
            uint32_t _size38;
            ::apache::thrift::protocol::TType _etype41;
            xfer += iprot->readListBegin(_etype41, _size38);
            this->tag.resize(_size38);
            uint32_t _i42;
            for (_i42 = 0; _i42 < _size38; ++_i42)
            {
              xfer += iprot->readByte(this->tag[_i42]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->key_arr.clear();
            uint32_t _size43;
            ::apache::thrift::protocol::TType _etype46;
            xfer += iprot->readListBegin(_etype46, _size43);
            this->key_arr.resize(_size43);
            uint32_t _i47;
            for (_i47 = 0; _i47 < _size43; ++_i47)
            {
              xfer += iprot->readI32(this->key_arr[_i47]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.key_arr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->round);
          this->__isset.round = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ks.clear();
            uint32_t _size48;
            ::apache::thrift::protocol::TType _etype51;
            xfer += iprot->readListBegin(_etype51, _size48);
            this->ks.resize(_size48);
            uint32_t _i52;
            for (_i52 = 0; _i52 < _size48; ++_i52)
            {
              xfer += iprot->readByte(this->ks[_i52]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.ks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k_part.clear();
            uint32_t _size53;
            ::apache::thrift::protocol::TType _etype56;
            xfer += iprot->readListBegin(_etype56, _size53);
            this->k_part.resize(_size53);
            uint32_t _i57;
            for (_i57 = 0; _i57 < _size53; ++_i57)
            {
              xfer += iprot->readByte(this->k_part[_i57]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.k_part = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->oramIndex);
          this->__isset.oramIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bu);
          this->__isset.bu = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->offset);
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t tMetaOblivEvict::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("tMetaOblivEvict");

  xfer += oprot->writeFieldBegin("tag", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BYTE, static_cast<uint32_t>(this->tag.size()));
    std::vector<int8_t> ::const_iterator _iter58;
    for (_iter58 = this->tag.begin(); _iter58 != this->tag.end(); ++_iter58)
    {
      xfer += oprot->writeByte((*_iter58));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key_arr", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->key_arr.size()));
    std::vector<int32_t> ::const_iterator _iter59;
    for (_iter59 = this->key_arr.begin(); _iter59 != this->key_arr.end(); ++_iter59)
    {
      xfer += oprot->writeI32((*_iter59));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("round", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->round);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ks", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BYTE, static_cast<uint32_t>(this->ks.size()));
    std::vector<int8_t> ::const_iterator _iter60;
    for (_iter60 = this->ks.begin(); _iter60 != this->ks.end(); ++_iter60)
    {
      xfer += oprot->writeByte((*_iter60));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("k_part", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BYTE, static_cast<uint32_t>(this->k_part.size()));
    std::vector<int8_t> ::const_iterator _iter61;
    for (_iter61 = this->k_part.begin(); _iter61 != this->k_part.end(); ++_iter61)
    {
      xfer += oprot->writeByte((*_iter61));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("oramIndex", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->oramIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bu", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->bu);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(this->offset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(tMetaOblivEvict &a, tMetaOblivEvict &b) {
  using ::std::swap;
  swap(a.tag, b.tag);
  swap(a.key_arr, b.key_arr);
  swap(a.round, b.round);
  swap(a.ks, b.ks);
  swap(a.k_part, b.k_part);
  swap(a.oramIndex, b.oramIndex);
  swap(a.bu, b.bu);
  swap(a.path, b.path);
  swap(a.offset, b.offset);
  swap(a.__isset, b.__isset);
}

tMetaOblivEvict::tMetaOblivEvict(const tMetaOblivEvict& other62) {
  tag = other62.tag;
  key_arr = other62.key_arr;
  round = other62.round;
  ks = other62.ks;
  k_part = other62.k_part;
  oramIndex = other62.oramIndex;
  bu = other62.bu;
  path = other62.path;
  offset = other62.offset;
  __isset = other62.__isset;
}
tMetaOblivEvict& tMetaOblivEvict::operator=(const tMetaOblivEvict& other63) {
  tag = other63.tag;
  key_arr = other63.key_arr;
  round = other63.round;
  ks = other63.ks;
  k_part = other63.k_part;
  oramIndex = other63.oramIndex;
  bu = other63.bu;
  path = other63.path;
  offset = other63.offset;
  __isset = other63.__isset;
  return *this;
}
void tMetaOblivEvict::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "tMetaOblivEvict(";
  out << "tag=" << to_string(tag);
  out << ", " << "key_arr=" << to_string(key_arr);
  out << ", " << "round=" << to_string(round);
  out << ", " << "ks=" << to_string(ks);
  out << ", " << "k_part=" << to_string(k_part);
  out << ", " << "oramIndex=" << to_string(oramIndex);
  out << ", " << "bu=" << to_string(bu);
  out << ", " << "path=" << to_string(path);
  out << ", " << "offset=" << to_string(offset);
  out << ")";
}


tMetaPerRe::~tMetaPerRe() noexcept {
}


void tMetaPerRe::__set_originIndex(const int32_t val) {
  this->originIndex = val;
}

void tMetaPerRe::__set_newIndex(const int32_t val) {
  this->newIndex = val;
}

void tMetaPerRe::__set_k_part(const std::vector<int8_t> & val) {
  this->k_part = val;
}
std::ostream& operator<<(std::ostream& out, const tMetaPerRe& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t tMetaPerRe::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->originIndex);
          this->__isset.originIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->newIndex);
          this->__isset.newIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k_part.clear();
            uint32_t _size64;
            ::apache::thrift::protocol::TType _etype67;
            xfer += iprot->readListBegin(_etype67, _size64);
            this->k_part.resize(_size64);
            uint32_t _i68;
            for (_i68 = 0; _i68 < _size64; ++_i68)
            {
              xfer += iprot->readByte(this->k_part[_i68]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.k_part = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t tMetaPerRe::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("tMetaPerRe");

  xfer += oprot->writeFieldBegin("originIndex", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->originIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("newIndex", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->newIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("k_part", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BYTE, static_cast<uint32_t>(this->k_part.size()));
    std::vector<int8_t> ::const_iterator _iter69;
    for (_iter69 = this->k_part.begin(); _iter69 != this->k_part.end(); ++_iter69)
    {
      xfer += oprot->writeByte((*_iter69));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(tMetaPerRe &a, tMetaPerRe &b) {
  using ::std::swap;
  swap(a.originIndex, b.originIndex);
  swap(a.newIndex, b.newIndex);
  swap(a.k_part, b.k_part);
  swap(a.__isset, b.__isset);
}

tMetaPerRe::tMetaPerRe(const tMetaPerRe& other70) {
  originIndex = other70.originIndex;
  newIndex = other70.newIndex;
  k_part = other70.k_part;
  __isset = other70.__isset;
}
tMetaPerRe& tMetaPerRe::operator=(const tMetaPerRe& other71) {
  originIndex = other71.originIndex;
  newIndex = other71.newIndex;
  k_part = other71.k_part;
  __isset = other71.__isset;
  return *this;
}
void tMetaPerRe::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "tMetaPerRe(";
  out << "originIndex=" << to_string(originIndex);
  out << ", " << "newIndex=" << to_string(newIndex);
  out << ", " << "k_part=" << to_string(k_part);
  out << ")";
}


tMetaPriRangeRet::~tMetaPriRangeRet() noexcept {
}


void tMetaPriRangeRet::__set_tag(const std::vector<int8_t> & val) {
  this->tag = val;
}

void tMetaPriRangeRet::__set_key_arr(const std::vector<int32_t> & val) {
  this->key_arr = val;
}

void tMetaPriRangeRet::__set_round(const int32_t val) {
  this->round = val;
}

void tMetaPriRangeRet::__set_ks(const std::vector<int8_t> & val) {
  this->ks = val;
}

void tMetaPriRangeRet::__set_k_part(const std::vector<int8_t> & val) {
  this->k_part = val;
}

void tMetaPriRangeRet::__set_oramIndex(const int32_t val) {
  this->oramIndex = val;
}

void tMetaPriRangeRet::__set_path(const int32_t val) {
  this->path = val;
}

void tMetaPriRangeRet::__set_bu_from(const int32_t val) {
  this->bu_from = val;
}

void tMetaPriRangeRet::__set_bu_max_inclusive(const int32_t val) {
  this->bu_max_inclusive = val;
}

void tMetaPriRangeRet::__set_offset(const int32_t val) {
  this->offset = val;
}

void tMetaPriRangeRet::__set_stash_index(const int32_t val) {
  this->stash_index = val;
}
std::ostream& operator<<(std::ostream& out, const tMetaPriRangeRet& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t tMetaPriRangeRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tag.clear();
            uint32_t _size72;
            ::apache::thrift::protocol::TType _etype75;
            xfer += iprot->readListBegin(_etype75, _size72);
            this->tag.resize(_size72);
            uint32_t _i76;
            for (_i76 = 0; _i76 < _size72; ++_i76)
            {
              xfer += iprot->readByte(this->tag[_i76]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->key_arr.clear();
            uint32_t _size77;
            ::apache::thrift::protocol::TType _etype80;
            xfer += iprot->readListBegin(_etype80, _size77);
            this->key_arr.resize(_size77);
            uint32_t _i81;
            for (_i81 = 0; _i81 < _size77; ++_i81)
            {
              xfer += iprot->readI32(this->key_arr[_i81]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.key_arr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->round);
          this->__isset.round = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ks.clear();
            uint32_t _size82;
            ::apache::thrift::protocol::TType _etype85;
            xfer += iprot->readListBegin(_etype85, _size82);
            this->ks.resize(_size82);
            uint32_t _i86;
            for (_i86 = 0; _i86 < _size82; ++_i86)
            {
              xfer += iprot->readByte(this->ks[_i86]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.ks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k_part.clear();
            uint32_t _size87;
            ::apache::thrift::protocol::TType _etype90;
            xfer += iprot->readListBegin(_etype90, _size87);
            this->k_part.resize(_size87);
            uint32_t _i91;
            for (_i91 = 0; _i91 < _size87; ++_i91)
            {
              xfer += iprot->readByte(this->k_part[_i91]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.k_part = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->oramIndex);
          this->__isset.oramIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bu_from);
          this->__isset.bu_from = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bu_max_inclusive);
          this->__isset.bu_max_inclusive = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->offset);
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->stash_index);
          this->__isset.stash_index = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t tMetaPriRangeRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("tMetaPriRangeRet");

  xfer += oprot->writeFieldBegin("tag", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BYTE, static_cast<uint32_t>(this->tag.size()));
    std::vector<int8_t> ::const_iterator _iter92;
    for (_iter92 = this->tag.begin(); _iter92 != this->tag.end(); ++_iter92)
    {
      xfer += oprot->writeByte((*_iter92));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key_arr", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->key_arr.size()));
    std::vector<int32_t> ::const_iterator _iter93;
    for (_iter93 = this->key_arr.begin(); _iter93 != this->key_arr.end(); ++_iter93)
    {
      xfer += oprot->writeI32((*_iter93));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("round", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->round);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ks", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BYTE, static_cast<uint32_t>(this->ks.size()));
    std::vector<int8_t> ::const_iterator _iter94;
    for (_iter94 = this->ks.begin(); _iter94 != this->ks.end(); ++_iter94)
    {
      xfer += oprot->writeByte((*_iter94));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("k_part", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BYTE, static_cast<uint32_t>(this->k_part.size()));
    std::vector<int8_t> ::const_iterator _iter95;
    for (_iter95 = this->k_part.begin(); _iter95 != this->k_part.end(); ++_iter95)
    {
      xfer += oprot->writeByte((*_iter95));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("oramIndex", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->oramIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bu_from", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->bu_from);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bu_max_inclusive", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(this->bu_max_inclusive);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->offset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stash_index", ::apache::thrift::protocol::T_I32, 11);
  xfer += oprot->writeI32(this->stash_index);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(tMetaPriRangeRet &a, tMetaPriRangeRet &b) {
  using ::std::swap;
  swap(a.tag, b.tag);
  swap(a.key_arr, b.key_arr);
  swap(a.round, b.round);
  swap(a.ks, b.ks);
  swap(a.k_part, b.k_part);
  swap(a.oramIndex, b.oramIndex);
  swap(a.path, b.path);
  swap(a.bu_from, b.bu_from);
  swap(a.bu_max_inclusive, b.bu_max_inclusive);
  swap(a.offset, b.offset);
  swap(a.stash_index, b.stash_index);
  swap(a.__isset, b.__isset);
}

tMetaPriRangeRet::tMetaPriRangeRet(const tMetaPriRangeRet& other96) {
  tag = other96.tag;
  key_arr = other96.key_arr;
  round = other96.round;
  ks = other96.ks;
  k_part = other96.k_part;
  oramIndex = other96.oramIndex;
  path = other96.path;
  bu_from = other96.bu_from;
  bu_max_inclusive = other96.bu_max_inclusive;
  offset = other96.offset;
  stash_index = other96.stash_index;
  __isset = other96.__isset;
}
tMetaPriRangeRet& tMetaPriRangeRet::operator=(const tMetaPriRangeRet& other97) {
  tag = other97.tag;
  key_arr = other97.key_arr;
  round = other97.round;
  ks = other97.ks;
  k_part = other97.k_part;
  oramIndex = other97.oramIndex;
  path = other97.path;
  bu_from = other97.bu_from;
  bu_max_inclusive = other97.bu_max_inclusive;
  offset = other97.offset;
  stash_index = other97.stash_index;
  __isset = other97.__isset;
  return *this;
}
void tMetaPriRangeRet::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "tMetaPriRangeRet(";
  out << "tag=" << to_string(tag);
  out << ", " << "key_arr=" << to_string(key_arr);
  out << ", " << "round=" << to_string(round);
  out << ", " << "ks=" << to_string(ks);
  out << ", " << "k_part=" << to_string(k_part);
  out << ", " << "oramIndex=" << to_string(oramIndex);
  out << ", " << "path=" << to_string(path);
  out << ", " << "bu_from=" << to_string(bu_from);
  out << ", " << "bu_max_inclusive=" << to_string(bu_max_inclusive);
  out << ", " << "offset=" << to_string(offset);
  out << ", " << "stash_index=" << to_string(stash_index);
  out << ")";
}


tFullBlockContent::~tFullBlockContent() noexcept {
}


void tFullBlockContent::__set_leafLabel(const int32_t val) {
  this->leafLabel = val;
}

void tFullBlockContent::__set_bucketLevel(const int32_t val) {
  this->bucketLevel = val;
}

void tFullBlockContent::__set_bucketOffset(const int32_t val) {
  this->bucketOffset = val;
}

void tFullBlockContent::__set_encData(const std::vector<int8_t> & val) {
  this->encData = val;
}
std::ostream& operator<<(std::ostream& out, const tFullBlockContent& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t tFullBlockContent::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->leafLabel);
          this->__isset.leafLabel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bucketLevel);
          this->__isset.bucketLevel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bucketOffset);
          this->__isset.bucketOffset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->encData.clear();
            uint32_t _size98;
            ::apache::thrift::protocol::TType _etype101;
            xfer += iprot->readListBegin(_etype101, _size98);
            this->encData.resize(_size98);
            uint32_t _i102;
            for (_i102 = 0; _i102 < _size98; ++_i102)
            {
              xfer += iprot->readByte(this->encData[_i102]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.encData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t tFullBlockContent::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("tFullBlockContent");

  xfer += oprot->writeFieldBegin("leafLabel", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->leafLabel);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bucketLevel", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->bucketLevel);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bucketOffset", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->bucketOffset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("encData", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BYTE, static_cast<uint32_t>(this->encData.size()));
    std::vector<int8_t> ::const_iterator _iter103;
    for (_iter103 = this->encData.begin(); _iter103 != this->encData.end(); ++_iter103)
    {
      xfer += oprot->writeByte((*_iter103));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(tFullBlockContent &a, tFullBlockContent &b) {
  using ::std::swap;
  swap(a.leafLabel, b.leafLabel);
  swap(a.bucketLevel, b.bucketLevel);
  swap(a.bucketOffset, b.bucketOffset);
  swap(a.encData, b.encData);
  swap(a.__isset, b.__isset);
}

tFullBlockContent::tFullBlockContent(const tFullBlockContent& other104) {
  leafLabel = other104.leafLabel;
  bucketLevel = other104.bucketLevel;
  bucketOffset = other104.bucketOffset;
  encData = other104.encData;
  __isset = other104.__isset;
}
tFullBlockContent& tFullBlockContent::operator=(const tFullBlockContent& other105) {
  leafLabel = other105.leafLabel;
  bucketLevel = other105.bucketLevel;
  bucketOffset = other105.bucketOffset;
  encData = other105.encData;
  __isset = other105.__isset;
  return *this;
}
void tFullBlockContent::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "tFullBlockContent(";
  out << "leafLabel=" << to_string(leafLabel);
  out << ", " << "bucketLevel=" << to_string(bucketLevel);
  out << ", " << "bucketOffset=" << to_string(bucketOffset);
  out << ", " << "encData=" << to_string(encData);
  out << ")";
}

} // namespace
