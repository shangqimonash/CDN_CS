/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "EdgeServer.h"

namespace services {


EdgeServer_send_data_message_args::~EdgeServer_send_data_message_args() noexcept {
}


uint32_t EdgeServer_send_data_message_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data_message);
          this->__isset.data_message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t EdgeServer_send_data_message_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EdgeServer_send_data_message_args");

  xfer += oprot->writeFieldBegin("data_message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data_message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


EdgeServer_send_data_message_pargs::~EdgeServer_send_data_message_pargs() noexcept {
}


uint32_t EdgeServer_send_data_message_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EdgeServer_send_data_message_pargs");

  xfer += oprot->writeFieldBegin("data_message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->data_message)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


EdgeServer_setup_rORAM_Stash_args::~EdgeServer_setup_rORAM_Stash_args() noexcept {
}


uint32_t EdgeServer_setup_rORAM_Stash_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->rORAMIndex);
          this->__isset.rORAMIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->stashSize);
          this->__isset.stashSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->rangeSupport);
          this->__isset.rangeSupport = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t EdgeServer_setup_rORAM_Stash_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EdgeServer_setup_rORAM_Stash_args");

  xfer += oprot->writeFieldBegin("rORAMIndex", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->rORAMIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stashSize", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->stashSize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rangeSupport", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->rangeSupport);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


EdgeServer_setup_rORAM_Stash_pargs::~EdgeServer_setup_rORAM_Stash_pargs() noexcept {
}


uint32_t EdgeServer_setup_rORAM_Stash_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EdgeServer_setup_rORAM_Stash_pargs");

  xfer += oprot->writeFieldBegin("rORAMIndex", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->rORAMIndex)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stashSize", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->stashSize)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rangeSupport", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->rangeSupport)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


EdgeServer_setup_rORAM_Stash_result::~EdgeServer_setup_rORAM_Stash_result() noexcept {
}


uint32_t EdgeServer_setup_rORAM_Stash_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t EdgeServer_setup_rORAM_Stash_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("EdgeServer_setup_rORAM_Stash_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


EdgeServer_setup_rORAM_Stash_presult::~EdgeServer_setup_rORAM_Stash_presult() noexcept {
}


uint32_t EdgeServer_setup_rORAM_Stash_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


EdgeServer_stash_upload_by_oram_index_args::~EdgeServer_stash_upload_by_oram_index_args() noexcept {
}


uint32_t EdgeServer_stash_upload_by_oram_index_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->rORAMIndex);
          this->__isset.rORAMIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->block_content_list.clear();
            uint32_t _size169;
            ::apache::thrift::protocol::TType _etype172;
            xfer += iprot->readListBegin(_etype172, _size169);
            this->block_content_list.resize(_size169);
            uint32_t _i173;
            for (_i173 = 0; _i173 < _size169; ++_i173)
            {
              xfer += this->block_content_list[_i173].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.block_content_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->blocknum);
          this->__isset.blocknum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t EdgeServer_stash_upload_by_oram_index_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EdgeServer_stash_upload_by_oram_index_args");

  xfer += oprot->writeFieldBegin("rORAMIndex", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->rORAMIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("block_content_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->block_content_list.size()));
    std::vector<tFullBlockContent> ::const_iterator _iter174;
    for (_iter174 = this->block_content_list.begin(); _iter174 != this->block_content_list.end(); ++_iter174)
    {
      xfer += (*_iter174).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("blocknum", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->blocknum);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


EdgeServer_stash_upload_by_oram_index_pargs::~EdgeServer_stash_upload_by_oram_index_pargs() noexcept {
}


uint32_t EdgeServer_stash_upload_by_oram_index_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EdgeServer_stash_upload_by_oram_index_pargs");

  xfer += oprot->writeFieldBegin("rORAMIndex", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->rORAMIndex)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("block_content_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->block_content_list)).size()));
    std::vector<tFullBlockContent> ::const_iterator _iter175;
    for (_iter175 = (*(this->block_content_list)).begin(); _iter175 != (*(this->block_content_list)).end(); ++_iter175)
    {
      xfer += (*_iter175).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("blocknum", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->blocknum)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


EdgeServer_stash_upload_by_oram_index_result::~EdgeServer_stash_upload_by_oram_index_result() noexcept {
}


uint32_t EdgeServer_stash_upload_by_oram_index_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t EdgeServer_stash_upload_by_oram_index_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("EdgeServer_stash_upload_by_oram_index_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


EdgeServer_stash_upload_by_oram_index_presult::~EdgeServer_stash_upload_by_oram_index_presult() noexcept {
}


uint32_t EdgeServer_stash_upload_by_oram_index_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


EdgeServer_stash_fetch_by_locations_args::~EdgeServer_stash_fetch_by_locations_args() noexcept {
}


uint32_t EdgeServer_stash_fetch_by_locations_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->rORAMIndex);
          this->__isset.rORAMIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->location_list.clear();
            uint32_t _size176;
            ::apache::thrift::protocol::TType _etype179;
            xfer += iprot->readListBegin(_etype179, _size176);
            this->location_list.resize(_size176);
            uint32_t _i180;
            for (_i180 = 0; _i180 < _size176; ++_i180)
            {
              xfer += this->location_list[_i180].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.location_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->blocknum);
          this->__isset.blocknum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t EdgeServer_stash_fetch_by_locations_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EdgeServer_stash_fetch_by_locations_args");

  xfer += oprot->writeFieldBegin("rORAMIndex", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->rORAMIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("location_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->location_list.size()));
    std::vector<tPhysicalLocation> ::const_iterator _iter181;
    for (_iter181 = this->location_list.begin(); _iter181 != this->location_list.end(); ++_iter181)
    {
      xfer += (*_iter181).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("blocknum", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->blocknum);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


EdgeServer_stash_fetch_by_locations_pargs::~EdgeServer_stash_fetch_by_locations_pargs() noexcept {
}


uint32_t EdgeServer_stash_fetch_by_locations_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EdgeServer_stash_fetch_by_locations_pargs");

  xfer += oprot->writeFieldBegin("rORAMIndex", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->rORAMIndex)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("location_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->location_list)).size()));
    std::vector<tPhysicalLocation> ::const_iterator _iter182;
    for (_iter182 = (*(this->location_list)).begin(); _iter182 != (*(this->location_list)).end(); ++_iter182)
    {
      xfer += (*_iter182).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("blocknum", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->blocknum)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


EdgeServer_stash_fetch_by_locations_result::~EdgeServer_stash_fetch_by_locations_result() noexcept {
}


uint32_t EdgeServer_stash_fetch_by_locations_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size183;
            ::apache::thrift::protocol::TType _etype186;
            xfer += iprot->readListBegin(_etype186, _size183);
            this->success.resize(_size183);
            uint32_t _i187;
            for (_i187 = 0; _i187 < _size183; ++_i187)
            {
              xfer += this->success[_i187].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t EdgeServer_stash_fetch_by_locations_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("EdgeServer_stash_fetch_by_locations_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector<tFullBlockContent> ::const_iterator _iter188;
      for (_iter188 = this->success.begin(); _iter188 != this->success.end(); ++_iter188)
      {
        xfer += (*_iter188).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


EdgeServer_stash_fetch_by_locations_presult::~EdgeServer_stash_fetch_by_locations_presult() noexcept {
}


uint32_t EdgeServer_stash_fetch_by_locations_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size189;
            ::apache::thrift::protocol::TType _etype192;
            xfer += iprot->readListBegin(_etype192, _size189);
            (*(this->success)).resize(_size189);
            uint32_t _i193;
            for (_i193 = 0; _i193 < _size189; ++_i193)
            {
              xfer += (*(this->success))[_i193].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


EdgeServer_edge_fetch_by_locations_args::~EdgeServer_edge_fetch_by_locations_args() noexcept {
}


uint32_t EdgeServer_edge_fetch_by_locations_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->rORAMIndex);
          this->__isset.rORAMIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->location_list.clear();
            uint32_t _size194;
            ::apache::thrift::protocol::TType _etype197;
            xfer += iprot->readListBegin(_etype197, _size194);
            this->location_list.resize(_size194);
            uint32_t _i198;
            for (_i198 = 0; _i198 < _size194; ++_i198)
            {
              xfer += this->location_list[_i198].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.location_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->startLeaf);
          this->__isset.startLeaf = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->blocknum);
          this->__isset.blocknum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t EdgeServer_edge_fetch_by_locations_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EdgeServer_edge_fetch_by_locations_args");

  xfer += oprot->writeFieldBegin("rORAMIndex", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->rORAMIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("location_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->location_list.size()));
    std::vector<tPhysicalLocation> ::const_iterator _iter199;
    for (_iter199 = this->location_list.begin(); _iter199 != this->location_list.end(); ++_iter199)
    {
      xfer += (*_iter199).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("startLeaf", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->startLeaf);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("blocknum", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->blocknum);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


EdgeServer_edge_fetch_by_locations_pargs::~EdgeServer_edge_fetch_by_locations_pargs() noexcept {
}


uint32_t EdgeServer_edge_fetch_by_locations_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EdgeServer_edge_fetch_by_locations_pargs");

  xfer += oprot->writeFieldBegin("rORAMIndex", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->rORAMIndex)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("location_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->location_list)).size()));
    std::vector<tPhysicalLocation> ::const_iterator _iter200;
    for (_iter200 = (*(this->location_list)).begin(); _iter200 != (*(this->location_list)).end(); ++_iter200)
    {
      xfer += (*_iter200).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("startLeaf", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->startLeaf)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("blocknum", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((*(this->blocknum)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


EdgeServer_edge_fetch_by_locations_result::~EdgeServer_edge_fetch_by_locations_result() noexcept {
}


uint32_t EdgeServer_edge_fetch_by_locations_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size201;
            ::apache::thrift::protocol::TType _etype204;
            xfer += iprot->readListBegin(_etype204, _size201);
            this->success.resize(_size201);
            uint32_t _i205;
            for (_i205 = 0; _i205 < _size201; ++_i205)
            {
              xfer += this->success[_i205].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t EdgeServer_edge_fetch_by_locations_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("EdgeServer_edge_fetch_by_locations_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector<tFullBlockContent> ::const_iterator _iter206;
      for (_iter206 = this->success.begin(); _iter206 != this->success.end(); ++_iter206)
      {
        xfer += (*_iter206).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


EdgeServer_edge_fetch_by_locations_presult::~EdgeServer_edge_fetch_by_locations_presult() noexcept {
}


uint32_t EdgeServer_edge_fetch_by_locations_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size207;
            ::apache::thrift::protocol::TType _etype210;
            xfer += iprot->readListBegin(_etype210, _size207);
            (*(this->success)).resize(_size207);
            uint32_t _i211;
            for (_i211 = 0; _i211 < _size207; ++_i211)
            {
              xfer += (*(this->success))[_i211].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


EdgeServer_edge_upload_by_locations_args::~EdgeServer_edge_upload_by_locations_args() noexcept {
}


uint32_t EdgeServer_edge_upload_by_locations_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->rORAMIndex);
          this->__isset.rORAMIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->block_content_list.clear();
            uint32_t _size212;
            ::apache::thrift::protocol::TType _etype215;
            xfer += iprot->readListBegin(_etype215, _size212);
            this->block_content_list.resize(_size212);
            uint32_t _i216;
            for (_i216 = 0; _i216 < _size212; ++_i216)
            {
              xfer += this->block_content_list[_i216].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.block_content_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->startLeaf);
          this->__isset.startLeaf = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->blocknum);
          this->__isset.blocknum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t EdgeServer_edge_upload_by_locations_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EdgeServer_edge_upload_by_locations_args");

  xfer += oprot->writeFieldBegin("rORAMIndex", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->rORAMIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("block_content_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->block_content_list.size()));
    std::vector<tFullBlockContent> ::const_iterator _iter217;
    for (_iter217 = this->block_content_list.begin(); _iter217 != this->block_content_list.end(); ++_iter217)
    {
      xfer += (*_iter217).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("startLeaf", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->startLeaf);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("blocknum", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->blocknum);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


EdgeServer_edge_upload_by_locations_pargs::~EdgeServer_edge_upload_by_locations_pargs() noexcept {
}


uint32_t EdgeServer_edge_upload_by_locations_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EdgeServer_edge_upload_by_locations_pargs");

  xfer += oprot->writeFieldBegin("rORAMIndex", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->rORAMIndex)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("block_content_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->block_content_list)).size()));
    std::vector<tFullBlockContent> ::const_iterator _iter218;
    for (_iter218 = (*(this->block_content_list)).begin(); _iter218 != (*(this->block_content_list)).end(); ++_iter218)
    {
      xfer += (*_iter218).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("startLeaf", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->startLeaf)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("blocknum", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((*(this->blocknum)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


EdgeServer_edge_upload_by_locations_result::~EdgeServer_edge_upload_by_locations_result() noexcept {
}


uint32_t EdgeServer_edge_upload_by_locations_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t EdgeServer_edge_upload_by_locations_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("EdgeServer_edge_upload_by_locations_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


EdgeServer_edge_upload_by_locations_presult::~EdgeServer_edge_upload_by_locations_presult() noexcept {
}


uint32_t EdgeServer_edge_upload_by_locations_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

void EdgeServerClient::send_data_message(const std::string& data_message)
{
  send_send_data_message(data_message);
}

void EdgeServerClient::send_send_data_message(const std::string& data_message)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("send_data_message", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  EdgeServer_send_data_message_pargs args;
  args.data_message = &data_message;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t EdgeServerClient::setup_rORAM_Stash(const int32_t rORAMIndex, const int32_t stashSize, const int32_t rangeSupport)
{
  send_setup_rORAM_Stash(rORAMIndex, stashSize, rangeSupport);
  return recv_setup_rORAM_Stash();
}

void EdgeServerClient::send_setup_rORAM_Stash(const int32_t rORAMIndex, const int32_t stashSize, const int32_t rangeSupport)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("setup_rORAM_Stash", ::apache::thrift::protocol::T_CALL, cseqid);

  EdgeServer_setup_rORAM_Stash_pargs args;
  args.rORAMIndex = &rORAMIndex;
  args.stashSize = &stashSize;
  args.rangeSupport = &rangeSupport;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t EdgeServerClient::recv_setup_rORAM_Stash()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("setup_rORAM_Stash") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  EdgeServer_setup_rORAM_Stash_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "setup_rORAM_Stash failed: unknown result");
}

int32_t EdgeServerClient::stash_upload_by_oram_index(const int32_t rORAMIndex, const std::vector<tFullBlockContent> & block_content_list, const int32_t blocknum)
{
  send_stash_upload_by_oram_index(rORAMIndex, block_content_list, blocknum);
  return recv_stash_upload_by_oram_index();
}

void EdgeServerClient::send_stash_upload_by_oram_index(const int32_t rORAMIndex, const std::vector<tFullBlockContent> & block_content_list, const int32_t blocknum)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("stash_upload_by_oram_index", ::apache::thrift::protocol::T_CALL, cseqid);

  EdgeServer_stash_upload_by_oram_index_pargs args;
  args.rORAMIndex = &rORAMIndex;
  args.block_content_list = &block_content_list;
  args.blocknum = &blocknum;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t EdgeServerClient::recv_stash_upload_by_oram_index()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("stash_upload_by_oram_index") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  EdgeServer_stash_upload_by_oram_index_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "stash_upload_by_oram_index failed: unknown result");
}

void EdgeServerClient::stash_fetch_by_locations(std::vector<tFullBlockContent> & _return, const int32_t rORAMIndex, const std::vector<tPhysicalLocation> & location_list, const int32_t blocknum)
{
  send_stash_fetch_by_locations(rORAMIndex, location_list, blocknum);
  recv_stash_fetch_by_locations(_return);
}

void EdgeServerClient::send_stash_fetch_by_locations(const int32_t rORAMIndex, const std::vector<tPhysicalLocation> & location_list, const int32_t blocknum)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("stash_fetch_by_locations", ::apache::thrift::protocol::T_CALL, cseqid);

  EdgeServer_stash_fetch_by_locations_pargs args;
  args.rORAMIndex = &rORAMIndex;
  args.location_list = &location_list;
  args.blocknum = &blocknum;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void EdgeServerClient::recv_stash_fetch_by_locations(std::vector<tFullBlockContent> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("stash_fetch_by_locations") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  EdgeServer_stash_fetch_by_locations_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "stash_fetch_by_locations failed: unknown result");
}

void EdgeServerClient::edge_fetch_by_locations(std::vector<tFullBlockContent> & _return, const int32_t rORAMIndex, const std::vector<tPhysicalLocation> & location_list, const int32_t startLeaf, const int32_t blocknum)
{
  send_edge_fetch_by_locations(rORAMIndex, location_list, startLeaf, blocknum);
  recv_edge_fetch_by_locations(_return);
}

void EdgeServerClient::send_edge_fetch_by_locations(const int32_t rORAMIndex, const std::vector<tPhysicalLocation> & location_list, const int32_t startLeaf, const int32_t blocknum)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("edge_fetch_by_locations", ::apache::thrift::protocol::T_CALL, cseqid);

  EdgeServer_edge_fetch_by_locations_pargs args;
  args.rORAMIndex = &rORAMIndex;
  args.location_list = &location_list;
  args.startLeaf = &startLeaf;
  args.blocknum = &blocknum;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void EdgeServerClient::recv_edge_fetch_by_locations(std::vector<tFullBlockContent> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("edge_fetch_by_locations") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  EdgeServer_edge_fetch_by_locations_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "edge_fetch_by_locations failed: unknown result");
}

int32_t EdgeServerClient::edge_upload_by_locations(const int32_t rORAMIndex, const std::vector<tFullBlockContent> & block_content_list, const int32_t startLeaf, const int32_t blocknum)
{
  send_edge_upload_by_locations(rORAMIndex, block_content_list, startLeaf, blocknum);
  return recv_edge_upload_by_locations();
}

void EdgeServerClient::send_edge_upload_by_locations(const int32_t rORAMIndex, const std::vector<tFullBlockContent> & block_content_list, const int32_t startLeaf, const int32_t blocknum)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("edge_upload_by_locations", ::apache::thrift::protocol::T_CALL, cseqid);

  EdgeServer_edge_upload_by_locations_pargs args;
  args.rORAMIndex = &rORAMIndex;
  args.block_content_list = &block_content_list;
  args.startLeaf = &startLeaf;
  args.blocknum = &blocknum;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t EdgeServerClient::recv_edge_upload_by_locations()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("edge_upload_by_locations") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  EdgeServer_edge_upload_by_locations_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "edge_upload_by_locations failed: unknown result");
}

bool EdgeServerProcessor::dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext) {
  ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    iprot->skip(::apache::thrift::protocol::T_STRUCT);
    iprot->readMessageEnd();
    iprot->getTransport()->readEnd();
    ::apache::thrift::TApplicationException x(::apache::thrift::TApplicationException::UNKNOWN_METHOD, "Invalid method name: '"+fname+"'");
    oprot->writeMessageBegin(fname, ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return true;
  }
  (this->*(pfn->second))(seqid, iprot, oprot, callContext);
  return true;
}

void EdgeServerProcessor::process_send_data_message(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("EdgeServer.send_data_message", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "EdgeServer.send_data_message");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "EdgeServer.send_data_message");
  }

  EdgeServer_send_data_message_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "EdgeServer.send_data_message", bytes);
  }

  try {
    iface_->send_data_message(args.data_message);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "EdgeServer.send_data_message");
    }
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "EdgeServer.send_data_message");
  }

  return;
}

void EdgeServerProcessor::process_setup_rORAM_Stash(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("EdgeServer.setup_rORAM_Stash", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "EdgeServer.setup_rORAM_Stash");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "EdgeServer.setup_rORAM_Stash");
  }

  EdgeServer_setup_rORAM_Stash_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "EdgeServer.setup_rORAM_Stash", bytes);
  }

  EdgeServer_setup_rORAM_Stash_result result;
  try {
    result.success = iface_->setup_rORAM_Stash(args.rORAMIndex, args.stashSize, args.rangeSupport);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "EdgeServer.setup_rORAM_Stash");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("setup_rORAM_Stash", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "EdgeServer.setup_rORAM_Stash");
  }

  oprot->writeMessageBegin("setup_rORAM_Stash", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "EdgeServer.setup_rORAM_Stash", bytes);
  }
}

void EdgeServerProcessor::process_stash_upload_by_oram_index(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("EdgeServer.stash_upload_by_oram_index", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "EdgeServer.stash_upload_by_oram_index");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "EdgeServer.stash_upload_by_oram_index");
  }

  EdgeServer_stash_upload_by_oram_index_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "EdgeServer.stash_upload_by_oram_index", bytes);
  }

  EdgeServer_stash_upload_by_oram_index_result result;
  try {
    result.success = iface_->stash_upload_by_oram_index(args.rORAMIndex, args.block_content_list, args.blocknum);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "EdgeServer.stash_upload_by_oram_index");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("stash_upload_by_oram_index", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "EdgeServer.stash_upload_by_oram_index");
  }

  oprot->writeMessageBegin("stash_upload_by_oram_index", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "EdgeServer.stash_upload_by_oram_index", bytes);
  }
}

void EdgeServerProcessor::process_stash_fetch_by_locations(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("EdgeServer.stash_fetch_by_locations", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "EdgeServer.stash_fetch_by_locations");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "EdgeServer.stash_fetch_by_locations");
  }

  EdgeServer_stash_fetch_by_locations_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "EdgeServer.stash_fetch_by_locations", bytes);
  }

  EdgeServer_stash_fetch_by_locations_result result;
  try {
    iface_->stash_fetch_by_locations(result.success, args.rORAMIndex, args.location_list, args.blocknum);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "EdgeServer.stash_fetch_by_locations");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("stash_fetch_by_locations", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "EdgeServer.stash_fetch_by_locations");
  }

  oprot->writeMessageBegin("stash_fetch_by_locations", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "EdgeServer.stash_fetch_by_locations", bytes);
  }
}

void EdgeServerProcessor::process_edge_fetch_by_locations(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("EdgeServer.edge_fetch_by_locations", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "EdgeServer.edge_fetch_by_locations");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "EdgeServer.edge_fetch_by_locations");
  }

  EdgeServer_edge_fetch_by_locations_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "EdgeServer.edge_fetch_by_locations", bytes);
  }

  EdgeServer_edge_fetch_by_locations_result result;
  try {
    iface_->edge_fetch_by_locations(result.success, args.rORAMIndex, args.location_list, args.startLeaf, args.blocknum);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "EdgeServer.edge_fetch_by_locations");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("edge_fetch_by_locations", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "EdgeServer.edge_fetch_by_locations");
  }

  oprot->writeMessageBegin("edge_fetch_by_locations", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "EdgeServer.edge_fetch_by_locations", bytes);
  }
}

void EdgeServerProcessor::process_edge_upload_by_locations(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("EdgeServer.edge_upload_by_locations", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "EdgeServer.edge_upload_by_locations");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "EdgeServer.edge_upload_by_locations");
  }

  EdgeServer_edge_upload_by_locations_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "EdgeServer.edge_upload_by_locations", bytes);
  }

  EdgeServer_edge_upload_by_locations_result result;
  try {
    result.success = iface_->edge_upload_by_locations(args.rORAMIndex, args.block_content_list, args.startLeaf, args.blocknum);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "EdgeServer.edge_upload_by_locations");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("edge_upload_by_locations", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "EdgeServer.edge_upload_by_locations");
  }

  oprot->writeMessageBegin("edge_upload_by_locations", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "EdgeServer.edge_upload_by_locations", bytes);
  }
}

::std::shared_ptr< ::apache::thrift::TProcessor > EdgeServerProcessorFactory::getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) {
  ::apache::thrift::ReleaseHandler< EdgeServerIfFactory > cleanup(handlerFactory_);
  ::std::shared_ptr< EdgeServerIf > handler(handlerFactory_->getHandler(connInfo), cleanup);
  ::std::shared_ptr< ::apache::thrift::TProcessor > processor(new EdgeServerProcessor(handler));
  return processor;
}

void EdgeServerConcurrentClient::send_data_message(const std::string& data_message)
{
  send_send_data_message(data_message);
}

void EdgeServerConcurrentClient::send_send_data_message(const std::string& data_message)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("send_data_message", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  EdgeServer_send_data_message_pargs args;
  args.data_message = &data_message;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

int32_t EdgeServerConcurrentClient::setup_rORAM_Stash(const int32_t rORAMIndex, const int32_t stashSize, const int32_t rangeSupport)
{
  int32_t seqid = send_setup_rORAM_Stash(rORAMIndex, stashSize, rangeSupport);
  return recv_setup_rORAM_Stash(seqid);
}

int32_t EdgeServerConcurrentClient::send_setup_rORAM_Stash(const int32_t rORAMIndex, const int32_t stashSize, const int32_t rangeSupport)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("setup_rORAM_Stash", ::apache::thrift::protocol::T_CALL, cseqid);

  EdgeServer_setup_rORAM_Stash_pargs args;
  args.rORAMIndex = &rORAMIndex;
  args.stashSize = &stashSize;
  args.rangeSupport = &rangeSupport;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t EdgeServerConcurrentClient::recv_setup_rORAM_Stash(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("setup_rORAM_Stash") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      EdgeServer_setup_rORAM_Stash_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "setup_rORAM_Stash failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t EdgeServerConcurrentClient::stash_upload_by_oram_index(const int32_t rORAMIndex, const std::vector<tFullBlockContent> & block_content_list, const int32_t blocknum)
{
  int32_t seqid = send_stash_upload_by_oram_index(rORAMIndex, block_content_list, blocknum);
  return recv_stash_upload_by_oram_index(seqid);
}

int32_t EdgeServerConcurrentClient::send_stash_upload_by_oram_index(const int32_t rORAMIndex, const std::vector<tFullBlockContent> & block_content_list, const int32_t blocknum)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("stash_upload_by_oram_index", ::apache::thrift::protocol::T_CALL, cseqid);

  EdgeServer_stash_upload_by_oram_index_pargs args;
  args.rORAMIndex = &rORAMIndex;
  args.block_content_list = &block_content_list;
  args.blocknum = &blocknum;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t EdgeServerConcurrentClient::recv_stash_upload_by_oram_index(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("stash_upload_by_oram_index") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      EdgeServer_stash_upload_by_oram_index_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "stash_upload_by_oram_index failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void EdgeServerConcurrentClient::stash_fetch_by_locations(std::vector<tFullBlockContent> & _return, const int32_t rORAMIndex, const std::vector<tPhysicalLocation> & location_list, const int32_t blocknum)
{
  int32_t seqid = send_stash_fetch_by_locations(rORAMIndex, location_list, blocknum);
  recv_stash_fetch_by_locations(_return, seqid);
}

int32_t EdgeServerConcurrentClient::send_stash_fetch_by_locations(const int32_t rORAMIndex, const std::vector<tPhysicalLocation> & location_list, const int32_t blocknum)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("stash_fetch_by_locations", ::apache::thrift::protocol::T_CALL, cseqid);

  EdgeServer_stash_fetch_by_locations_pargs args;
  args.rORAMIndex = &rORAMIndex;
  args.location_list = &location_list;
  args.blocknum = &blocknum;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void EdgeServerConcurrentClient::recv_stash_fetch_by_locations(std::vector<tFullBlockContent> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("stash_fetch_by_locations") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      EdgeServer_stash_fetch_by_locations_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "stash_fetch_by_locations failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void EdgeServerConcurrentClient::edge_fetch_by_locations(std::vector<tFullBlockContent> & _return, const int32_t rORAMIndex, const std::vector<tPhysicalLocation> & location_list, const int32_t startLeaf, const int32_t blocknum)
{
  int32_t seqid = send_edge_fetch_by_locations(rORAMIndex, location_list, startLeaf, blocknum);
  recv_edge_fetch_by_locations(_return, seqid);
}

int32_t EdgeServerConcurrentClient::send_edge_fetch_by_locations(const int32_t rORAMIndex, const std::vector<tPhysicalLocation> & location_list, const int32_t startLeaf, const int32_t blocknum)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("edge_fetch_by_locations", ::apache::thrift::protocol::T_CALL, cseqid);

  EdgeServer_edge_fetch_by_locations_pargs args;
  args.rORAMIndex = &rORAMIndex;
  args.location_list = &location_list;
  args.startLeaf = &startLeaf;
  args.blocknum = &blocknum;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void EdgeServerConcurrentClient::recv_edge_fetch_by_locations(std::vector<tFullBlockContent> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("edge_fetch_by_locations") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      EdgeServer_edge_fetch_by_locations_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "edge_fetch_by_locations failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t EdgeServerConcurrentClient::edge_upload_by_locations(const int32_t rORAMIndex, const std::vector<tFullBlockContent> & block_content_list, const int32_t startLeaf, const int32_t blocknum)
{
  int32_t seqid = send_edge_upload_by_locations(rORAMIndex, block_content_list, startLeaf, blocknum);
  return recv_edge_upload_by_locations(seqid);
}

int32_t EdgeServerConcurrentClient::send_edge_upload_by_locations(const int32_t rORAMIndex, const std::vector<tFullBlockContent> & block_content_list, const int32_t startLeaf, const int32_t blocknum)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("edge_upload_by_locations", ::apache::thrift::protocol::T_CALL, cseqid);

  EdgeServer_edge_upload_by_locations_pargs args;
  args.rORAMIndex = &rORAMIndex;
  args.block_content_list = &block_content_list;
  args.startLeaf = &startLeaf;
  args.blocknum = &blocknum;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t EdgeServerConcurrentClient::recv_edge_upload_by_locations(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("edge_upload_by_locations") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      EdgeServer_edge_upload_by_locations_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "edge_upload_by_locations failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

} // namespace

